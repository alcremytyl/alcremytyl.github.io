<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>Blog Title</title>
  <subtitle>This is a longer description about your blog.</subtitle>
  <link href="https://alcremytyl.github.io/feed/feed.xml" rel="self" />
  <link href="https://alcremytyl.github.io/" />
  <updated>2025-11-15T00:00:00Z</updated>
  <id>https://alcremytyl.github.io/</id>
  <author>
    <name>Your Name</name>
  </author>
  <entry>
    <title>CS-343 Quarter 3</title>
    <link href="https://alcremytyl.github.io/blog/cs-343_quarter_3/" />
    <updated>2025-11-15T00:00:00Z</updated>
    <id>https://alcremytyl.github.io/blog/cs-343_quarter_3/</id>
    <content type="html">&lt;p&gt;I read Make Computer Science Great Again&#39;s blog on &lt;a href=&quot;https://medium.com/@MakeComputerScienceGreatAgain/understanding-rest-api-a-comprehensive-guide-52fc10f6c9ed&quot;&gt;understanding REST APIs&lt;/a&gt;. As the title says, it&#39;s a comprehensive guide that dives deep into REST API principles, design, and their benefits. I chose this article as we&#39;re using a REST API for Thea&#39;s Pantry and I wanted to further familiarize myself with them in my free time.&lt;/p&gt;
&lt;p&gt;After defining what REST is, the author listed off the key principles of REST API design.&lt;/p&gt;
&lt;p&gt;The first is statelessness, the client must provide the server all the context it needs to do an operation. The server itself will hold no state. I saw this principle being upheld when we dug into the code for each operation of GIB (Guest Info Backend). For instance, &lt;code&gt;replaceGuest&lt;/code&gt; will fetch the current guest and swap in guest data given client parameters. It&#39;s all contained within tha endpoint&#39;s function call without making use of a greater app state. I wouldn&#39;t count RabbitMQ nor the config file as global state as the former is merely a logging tool and the latter just holds static port numbers and paths.&lt;/p&gt;
&lt;p&gt;Next two are resources and HTTP methods. Resources refers to some resource (guest data, inventory #) and designating a URL path for it. HTTP methods are our GET, POST, PUT, etc. We separated our resouces into &lt;code&gt;/guests&lt;/code&gt; for guests, &lt;code&gt;/version&lt;/code&gt; for the version number, and &lt;code&gt;/inventory&lt;/code&gt; for the total lb of inventory in our system. &lt;code&gt;/guests&lt;/code&gt; supports several HTTP methods on top of this.&lt;/p&gt;
&lt;p&gt;And then there&#39;s representation. In this case, we use &lt;code&gt;application/json&lt;/code&gt; but I found out you can also make use of YAML (&lt;code&gt;application/x-yaml&lt;/code&gt;) or protocol buffers (&lt;code&gt;application/protobuf&lt;/code&gt;) in the accept header in your project. I might experiment with this in my free time as I had no idea how protobufs were passed around prior to writing this.&lt;/p&gt;
&lt;p&gt;Then it goes to design principles. It says stuff like &amp;quot;use appropriate names for your urls&amp;quot; and &amp;quot;use status codes that make sense&amp;quot;. One thing from this section that caught my eye however was the bit about versioning. Instead of doing &lt;code&gt;/foo&lt;/code&gt;, it&#39;d be &lt;code&gt;/vN/foo&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the version number. This sounds pretty useful for widely used applications that make use of semantic versioning but I don&#39;t see myself using it in the forseeable future.&lt;/p&gt;
&lt;p&gt;And finally, the article describes the benefits. It noted simplicity, scalability, interoperability, and flexibility.
REST&#39;s design being &lt;code&gt;HTTP_METHOD /resource {data it asked for...}&lt;/code&gt; is easy to get a grasp of. For context, I&#39;ve tried using websockets for a personal project and couldn&#39;t make heads or tails of it after a solid week of attempts. REST took at an openapi spec to get a basic understanding of it.
The scalability would come from its statelessness, the system being made up of standalone methods would keep it efficient.
The article defined interoperability as &amp;quot;used with various programming languages and platforms&amp;quot; which is true but this applies to a ton of language-agnostic APIs. Protobufs for instance have a spec layed out in a &lt;code&gt;.proto&lt;/code&gt; file and any language can implement the structure akin to a C struct header. Though this is a minor nitpick to an otherwise great guide for getting a firmer grasp on REST APIs.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>CS-343 Quarter 1</title>
    <link href="https://alcremytyl.github.io/blog/cs-343_quarter_1/" />
    <updated>2025-10-05T00:00:00Z</updated>
    <id>https://alcremytyl.github.io/blog/cs-343_quarter_1/</id>
    <content type="html">&lt;p&gt;We did three things this quarter.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PlantUML diagrams&lt;/li&gt;
&lt;li&gt;Design pattern implementation&lt;/li&gt;
&lt;li&gt;dipping our toes into REST APIs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;PlantUML is a tool that generates diagrams based on their domain-specific language.
Here&#39;s an example structural diagram:&lt;/p&gt;
&lt;pre class=&quot;language-plantuml&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-plantuml&quot;&gt;&lt;span class=&quot;token delimiter punctuation&quot;&gt;@startuml&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;title&lt;/span&gt; Hello World - Structural Diagram

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; Hello &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    +sayHello&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; World &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    +receiveHello&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

Hello &lt;span class=&quot;token arrow operator&quot;&gt;--&gt;&lt;/span&gt; World &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; says &lt;span class=&quot;token string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;token delimiter punctuation&quot;&gt;@enduml&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://alcremytyl.github.io/blog/cs-343_quarter_1/H1V9LgJIoZ-286.avif 286w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://alcremytyl.github.io/blog/cs-343_quarter_1/H1V9LgJIoZ-286.webp 286w&quot;&gt;&lt;img loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://alcremytyl.github.io/blog/cs-343_quarter_1/H1V9LgJIoZ-286.png&quot; alt=&quot;Hello World Diagram&quot; width=&quot;286&quot; height=&quot;255&quot;&gt;&lt;/picture&gt;
&lt;p&gt;There are also ones known as &amp;quot;Sequence Diagrams&amp;quot; that outline a program&#39;s flow of operations while showing the scope of each variable. I don&#39;t know when it&#39;d come in handy but that may change once I do the capstone assignment.&lt;/p&gt;
&lt;p&gt;They look something like this:&lt;/p&gt;
&lt;pre class=&quot;language-plantuml&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-plantuml&quot;&gt;&lt;span class=&quot;token delimiter punctuation&quot;&gt;@startuml&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;participant&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Program&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Program
&lt;span class=&quot;token keyword&quot;&gt;participant&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;main()&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Main
&lt;span class=&quot;token keyword&quot;&gt;participant&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;readInput()&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Read
&lt;span class=&quot;token keyword&quot;&gt;participant&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;printOutput()&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Print

Program &lt;span class=&quot;token arrow operator&quot;&gt;-&gt;&lt;/span&gt; Main&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; call main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;activate&lt;/span&gt; Main

Main &lt;span class=&quot;token arrow operator&quot;&gt;-&gt;&lt;/span&gt; Read&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; call readInput&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;activate&lt;/span&gt; Read
Read &lt;span class=&quot;token arrow operator&quot;&gt;-&gt;&lt;/span&gt; Read&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; get user input
&lt;span class=&quot;token keyword&quot;&gt;deactivate&lt;/span&gt; Read
Main &lt;span class=&quot;token arrow operator&quot;&gt;&amp;lt;--&lt;/span&gt; Read&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; return input

Main &lt;span class=&quot;token arrow operator&quot;&gt;-&gt;&lt;/span&gt; Print&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; call printOutput&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;activate&lt;/span&gt; Print
Print &lt;span class=&quot;token arrow operator&quot;&gt;-&gt;&lt;/span&gt; Print&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; print to console
&lt;span class=&quot;token keyword&quot;&gt;deactivate&lt;/span&gt; Print

&lt;span class=&quot;token keyword&quot;&gt;deactivate&lt;/span&gt; Main
Program &lt;span class=&quot;token arrow operator&quot;&gt;&amp;lt;--&lt;/span&gt; Main&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; end main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token delimiter punctuation&quot;&gt;@enduml&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://alcremytyl.github.io/blog/cs-343_quarter_1/MsnBogl7sR-510.avif 510w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://alcremytyl.github.io/blog/cs-343_quarter_1/MsnBogl7sR-510.webp 510w&quot;&gt;&lt;img loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://alcremytyl.github.io/blog/cs-343_quarter_1/MsnBogl7sR-510.png&quot; alt=&quot;Hello World Diagram&quot; width=&quot;510&quot; height=&quot;320&quot;&gt;&lt;/picture&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;We then applied what we learned to refactor a duck codebase into variants that follow the Strategy and Singleton patterns. The usage of a structural diagram helped visualize the attribtues and relations between classes immensely. I&#39;d see myself using at least the structural diagrams for collaborative projects as we&#39;d iron out a design for our codebase to follow.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>CS-348 Quarter 1</title>
    <link href="https://alcremytyl.github.io/blog/cs-348_quarter_1/" />
    <updated>2025-10-04T00:00:00Z</updated>
    <id>https://alcremytyl.github.io/blog/cs-348_quarter_1/</id>
    <content type="html">&lt;p&gt;We used this quarter to get acquainted with the &lt;code&gt;git&lt;/code&gt; version control sofware. I&#39;ve used git for a few years but it was honestly the bare minimum.
My usage of it was effectively a cycle of writing out large chunks across several files,&lt;code&gt;git commit -am &amp;quot;some vaguely related message&amp;quot;&lt;/code&gt;, and &lt;code&gt;git push&lt;/code&gt;. That is all. No branches no checkouts, &lt;em&gt;maybe&lt;/em&gt; a &lt;code&gt;git reset --hard&lt;/code&gt; if I royally screwed up a system config (my old bspwm setup). That was all I knew and all I felt comfortable doing.&lt;/p&gt;
&lt;p&gt;That changed after trying out &lt;a href=&quot;https://github.com/pcottle&quot;&gt;pcottle&lt;/a&gt;&#39;s &lt;a href=&quot;https://learngitbranching.js.org/?locale=en_US&quot;&gt;Learn Git Branching&lt;/a&gt; for homework assignments. Its representation of git projects as flexible trees whose nodes may be moved around, cloned, and restructured as you please helped ease me into knowing not only what rebasing actually does (grafting nodes to other places) instead of the magic cure to make my push work. In fact, I tried applying knowledge from it in another class&#39;s assignment and it made differentiating between the base, intermediate, and advanced versions of the assignment easy. I thought git branches would&#39;ve had much more of a storage overhead but no, commits really are just lists with insertions and deletions rather than mass duplicating files.&lt;/p&gt;
&lt;p&gt;I&#39;ve heard that a lot of CS college graduates don&#39;t know version control is a thing until they go get trained by employers which shocked me at first. However, I&#39;m glad to know that our cirriculum didn&#39;t skip out on it. I&#39;d say learning tools like &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;mercurial&lt;/code&gt;, or even copy-pasting your folder is as essential as even writing the code itself. I wouldn&#39;t wish permanently losing your project to anyone.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>intro</title>
    <link href="https://alcremytyl.github.io/blog/1-intro/" />
    <updated>2025-09-15T00:00:00Z</updated>
    <id>https://alcremytyl.github.io/blog/1-intro/</id>
    <content type="html">&lt;p&gt;This will be where I post my blogs for CS-343 and CS-348.&lt;/p&gt;
</content>
  </entry>
</feed>